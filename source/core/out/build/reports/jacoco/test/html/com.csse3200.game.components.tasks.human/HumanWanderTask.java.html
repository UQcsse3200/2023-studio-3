<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HumanWanderTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">com.csse3200.game.components.tasks.human</a> &gt; <span class="el_source">HumanWanderTask.java</span></div><h1>HumanWanderTask.java</h1><pre class="source lang-java linenums">package com.csse3200.game.components.tasks.human;

import com.badlogic.gdx.math.Vector2;
import com.csse3200.game.ai.tasks.DefaultTask;
import com.csse3200.game.ai.tasks.PriorityTask;
import com.csse3200.game.ai.tasks.Task;
import com.csse3200.game.components.CombatStatsComponent;
import com.csse3200.game.physics.PhysicsLayer;
import com.csse3200.game.physics.components.ColliderComponent;
import com.csse3200.game.physics.components.HitboxComponent;
import com.csse3200.game.rendering.AnimationRenderComponent;
import com.csse3200.game.services.ServiceLocator;

/**
 * HumanWanderTask is the entry point for the engineer entity's behaviour. Instantiates subtasks HumanWaitTask,
 * HumanMovementTask and EngineerCombatTask, and manages transitions between the tasks. Engineer damage and death
 * handled in this class.
 */
public class HumanWanderTask extends DefaultTask implements PriorityTask {
  private static final int TOLERANCE = 1;
  private static final float STOP_DISTANCE = 0.5f;
  private static final int DEFAULT_PRIORITY = 1;
  private static final String DEATH_EVENT = &quot;deathStart&quot;;
  private static final String IDLE_EVENT = &quot;idleRight&quot;;
  private AnimationRenderComponent animator;
  private final float maxRange;
  private final float waitTime;
  private HumanMovementTask movementTask;
  private HumanWaitTask waitTask;
  private EngineerCombatTask combatTask;
  private Task currentTask;
<span class="fc" id="L32">  private boolean   isDead = false;</span>

<span class="fc" id="L34">  private boolean isSelected = false;</span>

<span class="fc" id="L36">  private boolean hasDied = false;</span>

  /**
   * Constructor of HumanWanderTask
   *
   * @param waitTime How long in seconds to wait between wandering.
   * @param maxRange Maximum detection and fighting range of the entity
   */
<span class="fc" id="L44">  public HumanWanderTask(float waitTime, float maxRange) {</span>
<span class="fc" id="L45">    this.waitTime = waitTime;</span>
<span class="fc" id="L46">    this.maxRange = maxRange;</span>
<span class="fc" id="L47">  }</span>

  /**
   * Fetches the priority of this task.
   * @return current priority of this task. Priority for this task is a set value and does not change.
   */
  @Override
  public int getPriority() {
<span class="nc" id="L55">    return DEFAULT_PRIORITY; // Low priority task</span>
  }

  /**
   * Starts the HumanWanderTask instance and instantiates subtasks (HumanWaitTask, HumanWanderTask, EngineerCombatTask).
   */
  @Override
  public void start() {
<span class="nc" id="L63">    super.start();</span>
<span class="nc" id="L64">    Vector2 startPos = owner.getEntity().getCenterPosition();</span>
<span class="nc" id="L65">    waitTask = new HumanWaitTask(waitTime);</span>
<span class="nc" id="L66">    waitTask.create(owner);</span>

<span class="nc" id="L68">    movementTask = new HumanMovementTask(startPos, STOP_DISTANCE);</span>
<span class="nc" id="L69">    movementTask.create(owner);</span>
<span class="nc" id="L70">    movementTask.start();</span>

<span class="nc" id="L72">    combatTask = new EngineerCombatTask(maxRange);</span>
<span class="nc" id="L73">    combatTask.create(owner);</span>
<span class="nc" id="L74">    combatTask.start();</span>

<span class="nc" id="L76">    currentTask = movementTask;</span>

<span class="nc" id="L78">    animator = owner.getEntity().getComponent(AnimationRenderComponent.class);</span>
<span class="nc" id="L79">  }</span>

  /**
   * Operates the main logic of the entity in this task. All calls to switch to particular states are determined during
   * the update phase.
   * The logical flow is:
   *      - Check if the entity has died since last update
   *      - Check if the entity has finished dying
   *      - If not dead
   */
  @Override
  public void update() {
<span class="nc" id="L91">    hasDied =  owner.getEntity().getComponent(CombatStatsComponent.class).isDead();</span>
    // Check if engineer has died since last update
<span class="nc bnc" id="L93" title="All 4 branches missed.">    if (!isDead &amp;&amp; hasDied) {</span>
<span class="nc" id="L94">      startDying();</span>
    }

<span class="nc" id="L97">    boolean justDied = owner.getEntity().getComponent(CombatStatsComponent.class).isDead();</span>
    // Check if engineer has died since last update
<span class="nc bnc" id="L99" title="All 4 branches missed.">    if (!isDead &amp;&amp; justDied) {</span>
<span class="nc" id="L100">      startDying();</span>
<span class="nc bnc" id="L101" title="All 4 branches missed.">    } else if (isDead &amp;&amp; animator.isFinished()) {</span>
<span class="nc" id="L102">      owner.getEntity().setFlagForDelete(true);</span>
      // Decrement the engineer count
<span class="nc" id="L104">      ServiceLocator.getGameEndService().updateEngineerCount();</span>
    }

    // otherwise doing engineer things since engineer is alive
<span class="nc bnc" id="L108" title="All 2 branches missed.">    else if (!isDead){</span>
<span class="nc" id="L109">      doEngineerThings();</span>
<span class="nc" id="L110">      currentTask.update();</span>
    }
<span class="nc" id="L112">  }</span>

  private void doEngineerThings() {
<span class="nc bnc" id="L115" title="All 2 branches missed.">    if (currentTask.getStatus() == Status.ACTIVE) {</span>
<span class="nc" id="L116">      return;</span>
    }

    // if the engineer is in move state and update has been called, engineer has arrived at destination
<span class="nc bnc" id="L120" title="All 2 branches missed.">    if (currentTask == movementTask) {</span>
<span class="nc" id="L121">      startWaiting();</span>
<span class="nc" id="L122">      owner.getEntity().getEvents().trigger(IDLE_EVENT);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">    } else if (combatTask.isTargetVisible()) {</span>
<span class="nc" id="L124">      float engY = owner.getEntity().getCenterPosition().y;</span>
<span class="nc" id="L125">      float targetY = combatTask.fetchTarget().y;</span>
      // if the engineer is positioned within the tolerance range of the mob's y position, enter combat state
<span class="nc bnc" id="L127" title="All 4 branches missed.">      if (engY &lt;  targetY + TOLERANCE &amp;&amp;</span>
              engY &gt; targetY - TOLERANCE) {
<span class="nc" id="L129">        startCombat();</span>

        // move into position for targeting mob
<span class="nc bnc" id="L132" title="All 2 branches missed.">      } else if (!this.isSelected()) {</span>
<span class="nc" id="L133">        Vector2 newPos = new Vector2(owner.getEntity().getPosition().x, combatTask.fetchTarget().y);</span>
<span class="nc" id="L134">        startMoving(newPos);</span>
      }
    }
<span class="nc" id="L137">  }</span>

  /**
   * Handle the dying phase of the entity. Triggers an event to play the appropriate media,
   * sets HitBox and Collider components to ignore contact (stops the body being pushed around)
   * and stops the current task.
   */
  private void startDying() {
<span class="nc" id="L145">    owner.getEntity().getEvents().trigger(DEATH_EVENT);</span>
<span class="nc" id="L146">    owner.getEntity().getComponent(ColliderComponent.class).setLayer(PhysicsLayer.NONE);</span>
<span class="nc" id="L147">    owner.getEntity().getComponent(HitboxComponent.class).setLayer(PhysicsLayer.NONE);</span>
<span class="nc" id="L148">    currentTask.stop();</span>
<span class="nc" id="L149">    isDead = true;</span>
<span class="nc" id="L150">  }</span>

  /**
   * Starts the wait task.
   */
  public void startWaiting() {
<span class="nc" id="L156">    swapTask(waitTask);</span>
<span class="nc" id="L157">  }</span>

  /**
   * Starts the movement task, to a particular destination
   * @param destination the Vector2 position to which the entity needs to move
   */
  public void startMoving(Vector2 destination) {
<span class="nc" id="L164">    movementTask.setTarget(destination);</span>
<span class="nc" id="L165">    swapTask(movementTask);</span>
<span class="nc" id="L166">  }</span>

  /**
   * Starts the combat task.
   */
  public void startCombat() {
<span class="nc" id="L172">    swapTask(combatTask);</span>
<span class="nc" id="L173">  }</span>

  /**
   * Allows manual switching of tasks, from the current task to the supplied newTask.
   * @param newTask the task being switched to.
   */
  private void swapTask(Task newTask) {
<span class="nc bnc" id="L180" title="All 2 branches missed.">    if (currentTask != null) {</span>
<span class="nc" id="L181">      currentTask.stop();</span>
    }
<span class="nc" id="L183">    currentTask = newTask;</span>
<span class="nc" id="L184">    currentTask.start();</span>
<span class="nc" id="L185">  }</span>

  private boolean isSelected() {
<span class="nc" id="L188">    return isSelected;</span>
  }

  public void setSelected(boolean isSelected) {
<span class="nc" id="L192">    this.isSelected = isSelected;</span>
<span class="nc" id="L193">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>