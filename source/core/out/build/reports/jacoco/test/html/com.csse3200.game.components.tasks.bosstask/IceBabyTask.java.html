<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IceBabyTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">com.csse3200.game.components.tasks.bosstask</a> &gt; <span class="el_source">IceBabyTask.java</span></div><h1>IceBabyTask.java</h1><pre class="source lang-java linenums">package com.csse3200.game.components.tasks.bosstask;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Timer;
import com.csse3200.game.ai.tasks.DefaultTask;
import com.csse3200.game.ai.tasks.PriorityTask;
import com.csse3200.game.components.CombatStatsComponent;
import com.csse3200.game.components.tasks.MovementTask;
import com.csse3200.game.entities.Entity;
import com.csse3200.game.entities.factories.NPCFactory;
import com.csse3200.game.physics.PhysicsEngine;
import com.csse3200.game.physics.PhysicsLayer;
import com.csse3200.game.physics.components.HitboxComponent;
import com.csse3200.game.physics.components.PhysicsMovementComponent;
import com.csse3200.game.rendering.AnimationRenderComponent;
import com.csse3200.game.services.GameTime;
import com.csse3200.game.services.ServiceLocator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class IceBabyTask extends DefaultTask implements PriorityTask {
    /** Constant names */
    private static final int PRIORITY = 3;
<span class="fc" id="L26">    private static final Vector2 ICEBABY_SPEED = new Vector2(1f, 1f);</span>
    private static final int MOVE_FORWARD_DELAY = 30;
    private static final int SMASH_RADIUS = 3;
    private static final int SMASH_DAMAGE = 30;
    private static final int ATK3_DAMAGE = 50;
    private static final float WALK_DISTANCE = 3.0f;
    private static final float STOP_DISTANCE = 0.1f;
    private static final int Y_TOP_BOUNDARY = 6;
    private static final int Y_BOT_BOUNDARY = 1;
<span class="fc" id="L35">    private static final Logger logger = LoggerFactory.getLogger(IceBabyTask.class);</span>
    /** Variable names */
    private PhysicsEngine physics;
    private GameTime gameTime;
    private STATE prevState;
    private AnimationRenderComponent animation;
    private Entity iceBaby;
    private Vector2 currentPos;
    private Vector2 walkPos;
    private MovementTask walkTask;
<span class="fc" id="L45">    private static int xRightBoundary = 17;</span>
<span class="fc" id="L46">    private static int xLeftBoundary = 12;</span>
<span class="fc" id="L47">    private boolean aoe = true;</span>
<span class="fc" id="L48">    private boolean startFlag = false;</span>
    private boolean isWalking;
    /** Animation constants */
    private static final String IDLE = &quot;startIdle&quot;;
    private static final String ATK1 = &quot;start1_atk&quot;;
    private static final String ATK2 = &quot;start2_atk&quot;;
    private static final String ATK3 = &quot;start3_atk&quot;;
    private static final String DEATH = &quot;startDeath&quot;;
    private static final String INTRO = &quot;startIntro_or_revive&quot;;
    private static final String STAGGER = &quot;startStagger&quot;;
    private static final String TAKEHIT = &quot;startTake_hit&quot;;
    private static final String WALK = &quot;startWalk&quot;;
<span class="fc" id="L60">    private enum STATE {</span>
<span class="fc" id="L61">        IDLE, ATK1, ATK2, ATK3, DEATH, INTRO, STAGGER, TAKEHIT, WALK</span>
    }
<span class="fc" id="L63">    private STATE iceBabyState = STATE.IDLE;</span>

    /**
     * Constructor for IceBabyTask
     */
<span class="fc" id="L68">    public IceBabyTask() {</span>
<span class="fc" id="L69">        physics = ServiceLocator.getPhysicsService().getPhysics();</span>
<span class="fc" id="L70">        gameTime = ServiceLocator.getTimeSource();</span>
<span class="fc" id="L71">    }</span>

    //ice baby should be able to poop out little mobs - spawn new
    //ice baby can also do aoe attack based on the animation
    //ice baby does punches to towers once it is close

    /**
     * Starts the Task and triggers for Ice Baby to be spawned
     */
    @Override
    public void start() {
<span class="nc" id="L82">        super.start();</span>
<span class="nc" id="L83">        iceBaby = owner.getEntity();</span>
<span class="nc" id="L84">        animation = iceBaby.getComponent(AnimationRenderComponent.class);</span>
<span class="nc" id="L85">        currentPos = iceBaby.getPosition();</span>
<span class="nc" id="L86">        iceBaby.getComponent(PhysicsMovementComponent.class).setSpeed(ICEBABY_SPEED);</span>
<span class="nc" id="L87">        Timer.schedule(new Timer.Task() {</span>
            @Override
            public void run() {
<span class="nc" id="L90">                changeState(STATE.INTRO);</span>
<span class="nc" id="L91">                animate();</span>
<span class="nc" id="L92">                startFlag = true;</span>
<span class="nc" id="L93">            }</span>
        }, 0.1f);

        // shift demon's boundary left every 30s
<span class="nc bnc" id="L97" title="All 2 branches missed.">        for (int i = 1; i &lt; 6; i++) {</span>
<span class="nc" id="L98">            Timer.schedule(new Timer.Task() {</span>
                @Override
                public void run() {
<span class="nc" id="L101">                    xLeftBoundary -= 2;</span>
<span class="nc" id="L102">                    xRightBoundary -= 2;</span>
<span class="nc" id="L103">                }</span>
            }, MOVE_FORWARD_DELAY * i);
        }

<span class="nc" id="L107">    }</span>

    /**
     * Updates the boss to start attacking and spawning new mobs
     */
    @Override
    public void update() {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (!startFlag) {</span>
<span class="nc" id="L115">            return;</span>
        }
<span class="nc" id="L117">        animate();</span>
<span class="nc" id="L118">        currentPos = iceBaby.getPosition();</span>
<span class="nc" id="L119">        int health = iceBaby.getComponent(CombatStatsComponent.class).getHealth();</span>

        // handle initial demon transformation
<span class="nc bnc" id="L122" title="All 4 branches missed.">        if (animation.getCurrentAnimation().equals(&quot;intro_or_revive&quot;) &amp;&amp; animation.isFinished()) {</span>
<span class="nc" id="L123">            changeState(STATE.IDLE); // start sequence</span>
        }
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (health &lt;= 0) {</span>
<span class="nc" id="L126">            changeState(STATE.DEATH);</span>
<span class="nc" id="L127">            animate();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            if (animation.isFinished()) {</span>
<span class="nc" id="L129">                iceBaby.setFlagForDelete(true);</span>
            }
        }

<span class="nc bnc" id="L133" title="All 5 branches missed.">        switch (iceBabyState) {</span>
<span class="nc" id="L134">            case IDLE -&gt; walk(getWalkPos());</span>
            case WALK -&gt; {
<span class="nc bnc" id="L136" title="All 2 branches missed.">                   if (walkComplete()) {</span>
<span class="nc" id="L137">                       changeState(STATE.IDLE);</span>
                   } else {
<span class="nc" id="L139">                       spawnMob();</span>
                   }
<span class="nc" id="L141">                }</span>
            case ATK1, ATK2 -&gt; {
<span class="nc bnc" id="L143" title="All 2 branches missed.">                if (animation.isFinished()) {</span>
<span class="nc" id="L144">                    ATK3();</span>
                }
            }
            case ATK3 -&gt; {
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (animation.isFinished()) {</span>
<span class="nc" id="L149">                    changeState(STATE.IDLE);</span>
                }
            }
        }
<span class="nc" id="L153">    }</span>

    /**
     * Changes the state of animation
     * @param state - the new animation
     */
    private void changeState(STATE state) {
<span class="nc" id="L160">        prevState = this.iceBabyState;</span>
<span class="nc" id="L161">        this.iceBabyState = state;</span>
<span class="nc" id="L162">    }</span>

    /**
     * Trigger the specific animation to play
     */
    private void animate() {
        // Check if same animation is being called
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (prevState.equals(iceBabyState)) {</span>
<span class="nc" id="L170">            return; // skip rest of function</span>
        }

<span class="nc bnc" id="L173" title="All 10 branches missed.">        switch (iceBabyState) {</span>
<span class="nc" id="L174">            case IDLE -&gt; iceBaby.getEvents().trigger(IDLE);</span>
<span class="nc" id="L175">            case WALK -&gt; iceBaby.getEvents().trigger(WALK);</span>
<span class="nc" id="L176">            case DEATH -&gt; iceBaby.getEvents().trigger(DEATH);</span>
<span class="nc" id="L177">            case ATK1 -&gt; iceBaby.getEvents().trigger(ATK1);</span>
<span class="nc" id="L178">            case ATK2 -&gt; iceBaby.getEvents().trigger(ATK2);</span>
<span class="nc" id="L179">            case ATK3 -&gt; iceBaby.getEvents().trigger(ATK3);</span>
<span class="nc" id="L180">            case TAKEHIT -&gt; iceBaby.getEvents().trigger(TAKEHIT);</span>
<span class="nc" id="L181">            case INTRO -&gt; iceBaby.getEvents().trigger(INTRO);</span>
<span class="nc" id="L182">            case STAGGER -&gt; iceBaby.getEvents().trigger(STAGGER);</span>
<span class="nc" id="L183">            default -&gt; logger.debug(&quot;iceBaby animation {state} not found&quot;);</span>
        }
<span class="nc" id="L185">        prevState = iceBabyState;</span>
<span class="nc" id="L186">    }</span>

    /**
     * Changes state of Ice Baby and moves it to the desired position.
     *
     * @param finalPos position for demon to jump to
     */
    private void walk(Vector2 finalPos) {
<span class="nc" id="L194">        changeState(STATE.WALK);</span>
<span class="nc" id="L195">        animate();</span>
<span class="nc" id="L196">        isWalking = true;</span>

<span class="nc" id="L198">        walkTask = new MovementTask(finalPos);</span>
<span class="nc" id="L199">        walkTask.create(owner);</span>
<span class="nc" id="L200">        walkTask.start();</span>

<span class="nc" id="L202">        logger.debug(&quot;Ice baby walk starting&quot;);</span>
<span class="nc" id="L203">    }</span>

    /**
     * Returns a random position 3 units away for the ice Baby to walk to.
     *
     * @return a position 3 units away
     */
    private Vector2 getWalkPos() {
        // check if boundary has shifted causing demon to be out of bounds
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (currentPos.x &gt; xRightBoundary) {</span>
<span class="nc" id="L213">            walkPos = new Vector2(currentPos.x - WALK_DISTANCE, currentPos.y); //jump back into boundary</span>
<span class="nc" id="L214">            return walkPos;</span>
        }

<span class="nc" id="L217">        float randomAngle = MathUtils.random(0, 2 * MathUtils.PI);</span>
<span class="nc" id="L218">        float x = WALK_DISTANCE * MathUtils.cos(randomAngle);</span>
<span class="nc" id="L219">        float y = WALK_DISTANCE * MathUtils.sin(randomAngle);</span>

        // check boundaries
<span class="nc bnc" id="L222" title="All 4 branches missed.">        if (x + currentPos.x &gt; xRightBoundary || x + currentPos.x &lt; xLeftBoundary) {</span>
<span class="nc" id="L223">            x *= -1;</span>
        }
<span class="nc bnc" id="L225" title="All 4 branches missed.">        if (y + currentPos.y &gt; Y_TOP_BOUNDARY || y + currentPos.y &lt; Y_BOT_BOUNDARY) {</span>
<span class="nc" id="L226">            y *= -1;</span>
        }

        // get final jump position
<span class="nc" id="L230">        float finalX = x + currentPos.x;</span>
<span class="nc" id="L231">        float finalY = y + currentPos.y;</span>
<span class="nc" id="L232">        walkPos = new Vector2(finalX, finalY);</span>
<span class="nc" id="L233">        return walkPos;</span>
    }

    /**
     * Returns a boolean to confirm whether the ice baby has completed a walk or not.
     *
     * @return true if demon has completed walk or not
     */
    private boolean walkComplete() {
<span class="nc" id="L242">        changeState(STATE.ATK1);</span>
<span class="nc" id="L243">        animate();</span>
<span class="nc bnc" id="L244" title="All 6 branches missed.">        if (currentPos.dst(walkPos) &lt;= STOP_DISTANCE &amp;&amp; isWalking &amp;&amp; animation.isFinished()) {</span>
<span class="nc" id="L245">            applyAoeDamage(getNearbyHumans(SMASH_RADIUS), SMASH_DAMAGE); // do damage upon landing</span>
<span class="nc" id="L246">            isWalking = false;</span>
<span class="nc" id="L247">            walkTask.stop();</span>
<span class="nc" id="L248">            return true;</span>
        }
<span class="nc" id="L250">        return false;</span>
    }

    /**
     * Changes the state of the animation and deals damage to nearby humans
     */
    private void ATK3() {
<span class="nc" id="L257">        changeState(STATE.ATK3);</span>
<span class="nc" id="L258">        animate();</span>
<span class="nc" id="L259">        Entity target = ServiceLocator.getEntityService().getClosestEntityOfLayer(iceBaby,</span>
                PhysicsLayer.HUMANS);
<span class="nc" id="L261">        CombatStatsComponent targetCombatStats = target.</span>
<span class="nc" id="L262">                getComponent(CombatStatsComponent.class);</span>
<span class="nc" id="L263">        Timer.schedule(new Timer.Task() {</span>
            @Override
            public void run() {
<span class="nc" id="L266">                targetCombatStats.hit(ATK3_DAMAGE);</span>
<span class="nc" id="L267">            }</span>
        }, 2f);
<span class="nc" id="L269">    }</span>

    /**
     * Creates a new mob triggered with the correct animation
     */
    private void spawnMob() {
<span class="nc" id="L275">        changeState(STATE.ATK2);</span>
<span class="nc" id="L276">        Entity newMob = NPCFactory.createSplittingWaterSlime(80);</span>
<span class="nc" id="L277">        newMob.setPosition((float) (iceBaby.getPosition().x + 0.5), (float) (iceBaby.getPosition().y + 0.5));</span>
<span class="nc" id="L278">        ServiceLocator.getEntityService().register(newMob);</span>
<span class="nc" id="L279">    }</span>

    /**
     * Applies aoe damage to nearby human entities.
     *
     * @param targets array of human entities to deal damage to
     */
    private void applyAoeDamage(Array&lt;Entity&gt; targets, int damage) {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        for (int i = 0; i &lt; targets.size; i++) {</span>
<span class="nc" id="L288">            Entity targetEntity = targets.get(i);</span>

<span class="nc" id="L290">            CombatStatsComponent targetCombatStats = targetEntity.</span>
<span class="nc" id="L291">                    getComponent(CombatStatsComponent.class);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (targetCombatStats != null) {</span>
<span class="nc" id="L293">                targetCombatStats.hit(damage);</span>
            }
        }
<span class="nc" id="L296">    }</span>

    /**
     * Returns a list of nearby entities with PhysicsLayer.HUMAN.
     *
     * @return nearby entities with the PhysicsLayer of HUMAN
     */
    private Array&lt;Entity&gt; getNearbyHumans(int radius) {
<span class="nc" id="L304">        Array&lt;Entity&gt; nearbyEntities = ServiceLocator.getEntityService().</span>
<span class="nc" id="L305">                getNearbyEntities(iceBaby, radius);</span>
<span class="nc" id="L306">        Array&lt;Entity&gt; nearbyHumans = new Array&lt;&gt;();</span>

        // iterate through nearby entities checking if they have desired properties
<span class="nc bnc" id="L309" title="All 2 branches missed.">        for (int i = 0; i &lt; nearbyEntities.size; i++) {</span>
<span class="nc" id="L310">            Entity targetEntity = nearbyEntities.get(i);</span>
<span class="nc" id="L311">            HitboxComponent targetHitbox = targetEntity.getComponent(HitboxComponent.class);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (targetHitbox == null) {</span>
<span class="nc" id="L313">                break;</span>
            }

            // check target layer
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (!PhysicsLayer.contains(PhysicsLayer.HUMANS, targetHitbox.</span>
<span class="nc" id="L318">                    getLayer())) {</span>
<span class="nc" id="L319">                break;</span>
            }

<span class="nc" id="L322">            nearbyHumans.add(targetEntity);</span>
        }
<span class="nc" id="L324">        return nearbyHumans;</span>
    }

    /**
     * Returns the priority of this task.
     *
     * @return priority of task
     */
    @Override
    public int getPriority() {
<span class="nc" id="L334">        return PRIORITY;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>